/* SPDX-License-Identifier: LGPL-2.1-or-later */

/*
 * \todo Document the interface and remove the related EXCLUDE_PATTERNS entry.
 */

module ipa.PiSP;

import "include/libcamera/ipa/core.mojom";

enum BufferMask {
	MaskID			= 0x00ffff,
	MaskStats		= 0x010000,
	MaskEmbeddedData	= 0x020000,
	MaskBayerData		= 0x040000,
	MaskExternalBuffer	= 0x100000,
};

struct InitConfig {
	libcamera.SharedFD fe;
	libcamera.SharedFD be;
};

struct SensorConfig {
	uint32 gainDelay;
	uint32 exposureDelay;
	uint32 vblankDelay;
	uint32 sensorMetadata;
};

struct IpaBuffers {
	uint32 bayerBufferId;
	uint32 embeddedBufferId;
	uint32 statsBufferId;
};

struct PrepareConfig {
	IpaBuffers buffers;
	bool embeddedBufferPresent;
	libcamera.ControlList sensorControls;
	libcamera.ControlList requestControls;
};

struct StartConfig {
	libcamera.ControlList controls;
	int32 dropFrameCount;
};

interface IPAPiSPInterface {
	init(libcamera.IPASettings settings, InitConfig config)
		=> (int32 ret, SensorConfig sensorConfig);

	start(libcamera.ControlList controls) => (StartConfig startConfig);
	stop();

	/**
	 * \fn configure()
	 * \brief Configure the IPA stream and sensor settings
	 * \param[in] sensorInfo Camera sensor information
	 * \param[in] streamConfig Configuration of all active streams
	 * \param[in] entityControls Controls provided by the pipeline entities
	 * \param[in] ipaConfig Pipeline-handler-specific configuration data
	 * \param[out] controls Controls to apply by the pipeline entity
	 *
	 * This function shall be called when the camera is configured to inform
	 * the IPA of the camera's streams and the sensor settings.
	 *
	 * The \a sensorInfo conveys information about the camera sensor settings that
	 * the pipeline handler has selected for the configuration.
	 *
	 * The \a ipaConfig and \a controls parameters carry data passed by the
	 * pipeline handler to the IPA and back.
	 */
	configure(libcamera.IPACameraSensorInfo sensorInfo,
		  map<uint32, libcamera.IPAStream> streamConfig,
		  libcamera.ControlInfoMap sensorControls,
		  uint32 transform)
		=> (int32 ret, libcamera.ControlList controls);

	/**
	 * \fn mapBuffers()
	 * \brief Map buffers shared between the pipeline handler and the IPA
	 * \param[in] buffers List of buffers to map
	 *
	 * This function informs the IPA module of memory buffers set up by the
	 * pipeline handler that the IPA needs to access. It provides dmabuf
	 * file handles for each buffer, and associates the buffers with unique
	 * numerical IDs.
	 *
	 * IPAs shall map the dmabuf file handles to their address space and
	 * keep a cache of the mappings, indexed by the buffer numerical IDs.
	 * The IDs are used in all other IPA interface functions to refer to
	 * buffers, including the unmapBuffers() function.
	 *
	 * All buffers that the pipeline handler wishes to share with an IPA
	 * shall be mapped with this function. Buffers may be mapped all at once
	 * with a single call, or mapped and unmapped dynamically at runtime,
	 * depending on the IPA protocol. Regardless of the protocol, all
	 * buffers mapped at a given time shall have unique numerical IDs.
	 *
	 * The numerical IDs have no meaning defined by the IPA interface, and 
	 * should be treated as opaque handles by IPAs, with the only exception
	 * that ID zero is invalid.
	 *
	 * \sa unmapBuffers()
	 */
	mapBuffers(array<libcamera.IPABuffer> buffers);

	/**
	 * \fn unmapBuffers()
	 * \brief Unmap buffers shared by the pipeline to the IPA
	 * \param[in] ids List of buffer IDs to unmap
	 *
	 * This function removes mappings set up with mapBuffers(). Numerical
	 * IDs of unmapped buffers may be reused when mapping new buffers.
	 *
	 * \sa mapBuffers()
	 */
	unmapBuffers(array<uint32> ids);

	[async] signalIpaPrepare(PrepareConfig config);
};

interface IPAPiSPEventInterface {
	[async] ipaPrepareComplete(IpaBuffers buffers);
	[async] setDelayedControls(libcamera.ControlList controls);
};
